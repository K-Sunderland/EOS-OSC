#include <OneBitDisplay.h>
#include "OLED.h"
#include "Encoder.h"
#include "OSC.h"
#include "submaster.h"
#include "button.h"
#include <string.h>
#define PAGE_NUM  3
#define DISPLAY_NUM 6
#define ENCODER_NUM 7
#define SELECTOR_INDEX 0
enum class State {Splash, Run, Switch, Update};

OLED displays[6];
Encoder encoders[7];
Sub sub1;
Button btn1;

int val = 0;


WHEEL_TYPE type[PAGE_NUM][7] =
{
  {SELECTOR, RED, GREEN, BLUE, WHITE, AMBER, LEVEL},
  {SELECTOR, TILT, ZOOM, PAN, BLUE, BLUE, LEVEL}
};

char *typeText[PAGE_NUM][7] =
{
  {(char *)"", (char *)"Red    ", (char *)"Green", (char *)"Blue    ", (char *)"White      ", (char *)"Amber      "},
  {(char *)"", (char *)"Tilt   ", (char *)"Zoom", (char *)"Pan     ", (char *)"Blue       ", (char *)"           "},
  (char *)"", (char *)"Hello   ", (char *)"Purple    ", (char *)"Red     ", (char *)"Blue       ", (char *)"           "
};

int sdaPins[] = {22, 23, 24, 25, 26, 27};
int encoderAPins[] = {30, 32, 34, 36, 38, 40, 42};
int encoderBPins[] = {31, 33, 35, 37, 39, 41, 43};
int btnPins[] = {44, 45, 46, 47, 48, -1};
int directions[] = {FORWARD, FORWARD, FORWARD, FORWARD, FORWARD, FORWARD, FORWARD};
int scales[] = {1, 10, 10, 3, 3, 3, 3};
int curPage = 1;
bool oledChanges = true;

State cur_state = State::Splash;
State next_state = State::Splash;

const uint8_t etcSplash[] PROGMEM = {
  0x42, 0x4d, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x28, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
  0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xce, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x33, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xff, 0xff, 0xff, 0x73, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x39, 0xde, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xce, 0x37, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xcc, 0x33, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x73, 0x39, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0xcf, 0x7f, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xce, 0x31, 0xcc, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf9, 0xc4, 0x23, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xce, 0x31, 0x19, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0xbb, 0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0xce, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xce, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xdf, 0x79, 0xf0, 0x00, 0x1f, 0xfe, 0x3f, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0x8e, 0x30, 0xf8, 0x00, 0x0f, 0xfe, 0x3f, 0xfc, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0x8c, 0x30, 0xfc, 0x00, 0x07, 0xfe, 0x3f, 0xf0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x30, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0x8e, 0x38, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe3, 0x04, 0x10, 0xf0, 0x00, 0x1f, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe3, 0x8c, 0x10, 0xf8, 0x00, 0x0f, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0x8e, 0x30, 0xfc, 0x00, 0x07, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x30, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0x8c, 0x30, 0xf0, 0x00, 0x1f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0x8e, 0x31, 0xf8, 0x00, 0x0f, 0x80, 0x00, 0x78, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xfc, 0x00, 0x07, 0xc0, 0x00, 0x3c, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xce, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0xdf, 0x79, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x73, 0xb9, 0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xcc, 0x21, 0x19, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xc4, 0x21, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x31, 0xc4, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe7, 0xdf, 0x7f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xb9, 0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x73, 0x39, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xcc, 0x33, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xcc, 0x37, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x39, 0xce, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x73, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xce, 0x73, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xce, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x79, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xde, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf7, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00
};









void setup()
{

  initSerial();
  // This is a hack around an Arduino bug. It was taken from the OSC library
  //examples
#ifdef BOARD_HAS_USB_SERIAL
  while (!SerialUSB);
#else
  while (!Serial);
#endif

  sub1.init(A1);
  btn1.init(2,BUMP_GO,1);
  
  for (uint8_t i = 0; i < 6; i++)
  {
    displays[i].initOled(sdaPins[i]);
    encoders[i].initEncoder(encoderAPins[i], encoderBPins[i], btnPins[i], directions[i], type[curPage][i], scales[i]);
  }

    
     
}

void splash()
{

  // clear splashscreen once connected 
  if (connected)
  {
    next_state = State::Update;

    // shut displays off to hide timing delay
    for(int i = 0; i < DISPLAY_NUM; i++)
    {
      displays[i].power(false);  
    }

    // clear display
    for(int i = 0; i < DISPLAY_NUM; i++)
    {
     displays[i].clearDisplay(); 
    }

    // reenable power
        for(int i = 0; i < DISPLAY_NUM; i++)
    {
      displays[i].power(true);  
    }

    //initialize fader banks
    String subInit = "/eos/fader/1/config/10";
    sendOscMessage(subInit);
  }
  else
  {

  // if not connected to console show splashscreen
    for (auto& disp : displays)
    {
      disp.displaySplash((uint8_t *)etcSplash);
      
    }

  }

}


void run()
{


  sub1.updateSub();
  btn1.updateButton();
  //send encoder data
  for (auto& enc : encoders)
  {
    enc.updateEncoder();
  }

  // move to switching state if selector is pressed
  if (encoders[SELECTOR_INDEX].updateButton())
  {
    displays[SELECTOR_INDEX].displayText((char*)"Switching   ", 2, 2);
    next_state = State::Switch;
  }
}

bool initSwitching = false;
int tmpPage;

void switching()
{



  if (!initSwitching)
  {
    tmpPage = curPage;
    initSwitching = true;
  }



  int8_t motion = encoders[SELECTOR_INDEX].updateEncoder();


    
  

  tmpPage += motion;


  if (tmpPage >= PAGE_NUM)
    tmpPage = 0;

  if (tmpPage < 0)
    tmpPage = PAGE_NUM - 1;

  
if(motion != 0)
{
  for(int i = 0; i < DISPLAY_NUM; i++)
  {
    displays[i].displayText(typeText[tmpPage][i], 2, 2);
  }
}


  if (encoders[SELECTOR_INDEX].updateButton())
  {
    initSwitching = false;
    curPage = tmpPage;
    next_state = State::Update;
  }
}

void update()
{


  for (uint8_t i = 0; i < 6; i++)
  {
    displays[i].displayText(typeText[curPage][i], 2, 2);
  }

  next_state = State::Run;
  displays[SELECTOR_INDEX].displayText((char*)"Running   ", 2, 2);
}


void loop()
{
  cur_state = next_state;
  switch (cur_state)
  {
    case State::Splash: splash(); break;
    case State::Run: run() ; break;
    case State::Switch: switching(); break;
    case State::Update: update(); break;
  }



//show splashscreen if console is disconnected
/*
if(!connected)
{
 next_state = State::Splash;   
}
*/
   
  checkOSC();
}
